// 剑指 Offer 49. 丑数
// 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

// 示例:
// 输入: n = 10
// 输出: 12
// 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

// -------------------第三次刷-----------------------
// 2021年5月31日10:56:00
// 准备第一次社招
// 思路: 动态规划. 一个丑数只可能是另一个丑数a乘以2或者另一个丑数b乘以3或者另一个丑数c乘以5得来. 
// 最直白的想法是把每个数分别乘以2,3,5, 但是得到的数顺序未知. 可以用a,b,c三个数分别来记录索引里
// 乘过a,b,c的, 如a代表序列里索引从0到a都乘过2并且结果已经接在序列里. 这样每次比较3个数n2, n3, n5找到最小的即可.
// 而且保证了每个数都乘过2,3,5

#include <vector>
using namespace std;
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n, 0);
        dp[0] = 1;
        int a=0, b=0, c=0;
        for(int i=1;i<n;i++){
            int n2 = dp[a]*2;
            int n3 = dp[b]*3;
            int n5 = dp[c]*5;
            dp[i] = min(min(n2, n3), n5);
            //注意这里不能用else if, 因为可能存在重复
            if(dp[i]==n2)
                a++;
            if(dp[i]==n3)
                b++;
            if(dp[i]==n5)
                c++;
        }
        return dp[n-1];
    }
};