#include <algorithm>
#include <vector>
using namespace std;

// 31. 下一个排列
// 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
// 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
// 必须 原地 修改，只允许使用额外常数空间。

// 示例 1：
// 输入：nums = [1,2,3]
// 输出：[1,3,2]

// 示例 2：
// 输入：nums = [3,2,1]
// 输出：[1,2,3]

// 示例 3：
// 输入：nums = [1,1,5]
// 输出：[1,5,1]

// 示例 4：
// 输入：nums = [1]
// 输出：[1]

// -------------------第二次刷-----------------------
// 2021年6月9日10:45:22
// 准备第一次社招
// 思路: 基本思路肯定是某两个数交换. 关键在于如何确定这两个数. 因为数值要变大, 所以左边被交换到右边的数a[i]肯定是小于右边的某个数a[j]. 
// 同时又因为求下一个排列, 所以a[i]要尽量靠近右边. 因此a[i]就是从右往前第一个非降序的数. 即a[i]<a[i+1]. 至于a[j], 因为求下一个排列, 
// 交换到前面的a[j]应该是a[i]右边比a[i]的数里的最小的数. 交换完以后还不一定保证就是下一个序列, 应该将原本a[i]位置后面的数从小到大排列才行

// 注意: 这里可以间接得到的信息是a[i]右边的数从左往右看都是降序. 另外, a[j]>a[i]>a[j+1], 因此swap(a[i], a[j])后右边仍然为降序. 因此只需要reverse即等于sort
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        // 步骤1：从后向前查找第一个顺序对 (i,i+1)，满足 a[i] < a[i+1]。「较小数」即为 a[i]
        while (i >= 0 && nums[i] >= nums[i + 1])
            i--;
        // 步骤2：在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i] < a[j]。较大数即为 a[j]
        if (i >= 0) {  //如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，我们直接跳过步骤 2
                       //执行步骤 3，即可得到最小的升序序列
            int j = nums.size() - 1;
            while (j >= 0 && nums[i] >= nums[j])
                j--;
            swap(nums[i], nums[j]);
        }
        // 步骤3：反转区间 [i+1,n)[i+1,n) 使其变为升序，而无需对该区间进行排序
        reverse(nums.begin() + 1 + i, nums.end());
    }
};