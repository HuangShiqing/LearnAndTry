// 621. 任务调度器
// 给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，
// 并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。
// 然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，
// 或者在待命状态。你需要计算完成所有任务所需要的 最短时间 。

// 示例 1：
// 输入：tasks = ["A","A","A","B","B","B"], n = 2
// 输出：8
// 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
//      在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 

// 示例 2：
// 输入：tasks = ["A","A","A","B","B","B"], n = 0
// 输出：6
// 解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
// ["A","A","A","B","B","B"]
// ["A","B","A","B","A","B"]
// ["B","B","B","A","A","A"]
// ...
// 诸如此类

// 示例 3：
// 输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
// 输出：16
// 解释：一种可能的解决方案是：
//      A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A

// -------------------第二次刷-----------------------
// 2021年7月20日10:53:04
// 准备第一次社招
// 思路: 同一类任务放一列, 执行顺序是行主序, 最少是n列以此保证同一类任务的冷却时间(最后一行不需要考虑冷却). 行数取决于
// 最大同类型任务的数量. 最后一行所需的时间取决于最长时间任务的数量, 那么所需时间就是cnt+(n+1)*(v[0]-1). 但是可能总任务
// 数量大于这个结果值(此时多出来的任务可以竖着插在右边), 那么需要求两者的最大值

// 这个题解非常不错https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/

#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        // 求最大同类任务的数量作为行数
        vector<int> v(26);
        for(char c : tasks)
            v[c-'A'] ++;
        sort(v.begin(), v.end(), [](int& x, int& y){return x>y;});

        // 求最长时间任务的数量, 用于计算最后一行的时间
        int cnt=1;
        while(cnt<v.size()&&v[cnt]==v[0]) 
            cnt++;
        
        // 求两者最大值
        int len = tasks.size();
        return max(len, cnt+(n+1)*(v[0]-1));
    }
};