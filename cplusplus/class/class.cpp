// 一:属性都设置为private
// 1.将成员属性设置为private后用户自己可以通过开放对应public成员函数接口控制读写权限
// 2.可以控制属性赋值的合法性

// 二:class和struct的差别就在于默认权限

// 三:构造和析构函数
// 1.构造和析构都没有有返回值
// 2.构造函数有参数,可以被重载
// 3.析构函数没有参数,不能被重载

// 四:构造函数分类和调用方法
// 1.括号法调用构造函数
// 2.显式法调用构造函数
// 3.隐式转换法

// 五:拷贝构造函数的使用场景
// 1.手动调用拷贝构造函数,用一个实例去初始化另一个实例
// 2.值传递方式调用函数
// 3.以值传递方式返回

// 六:构造函数
// 1.系统默认给类提供默认构造函数、默认拷贝构造函数、默认析构函数
// 2.用户提供有参构造函数后则系统不再提供默认构造函数,但是仍提供拷贝构造
// 3.用户提供拷贝构造函数后则系统不再提供任何其他默认函数

// 七:拷贝构造函数的深浅拷贝
// 系统提供的默认拷贝构造函数为浅拷贝,即对于属性直接逐字节拷贝,如果是指针属性则当实例1释放之后
// 实例2的指针属性会指向异常

// 八:用初始化列表构造函数初始化属性

// 九:一个类A实例作为另外一个类B的属性,先构造A,再构造B,先析构B,再析构A

class Person {
  int m_A;  // class成员的默认权限是private,struct成员的默认权限是public
 public:  //类内类外(类和实例对象)都可以被访问
  Person(){
      //无参构造函数,即默认构造函数

  };
  Person(int a){
      //有参普通构造函数

  };
  Person(int b, int c) : m_B(b), m_C(c) {
    //初始化列表构造函数
  };
  Person(const Person& person){
      //有参拷贝构造函数

  };
  ~Person(){

  };

  void set_B(int b) {  //在public一般会设置关于属性m_B的读写接口
    if (b < 10)        //还能控制属性设置的合法性
      m_B = b;
  }
  int get_B() { return m_B; }

 protected:  //类内可以被访问，实例对象不可以访问
 private:    //类内可以被访问，实例对象不可以访问
  int m_B;   //属性一般都放在private里,实例不能直接访问
  int m_C;
};

int main() {
  // 1.括号法调用构造函数
  Person p1;      //默认构造函数
  Person p2(1);   //有参普通构造函数
  Person p3(p1);  //拷贝构造函数
  //   注意事项
  //   调用默认构造函数时不要加括号，否则会被认为是函数声明

  // 2.显式法调用构造函数
  Person p4;               //默认构造函数
  Person p5 = Person(1);   //有参普通构造函数
  Person p6 = Person(p4);  //拷贝构造函数
  Person(1);               //匿名对象，当前行运行结束即释放
  //   注意事项
  //   不要用拷贝构造函数初始化一个匿名对象，编译器会等价Person(p1)=Person
  //   p1，出现重定义问题 Person(p1)

  //   3.隐式转换法
  Person p7 = 1;  //相当于 Person p7 = Person(1);
}